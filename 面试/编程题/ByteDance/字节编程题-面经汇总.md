## 圆环上有 10 个点，编号 0~9 。从 0 出发，每次可以顺时针或逆时针走一格，请问一共走且仅走 n 步回到原点的方法有多少种。

```java
public class Solution {
    public int circle(int stepCount) {
        int mod = 1000000007;
        // 二位数组的[x][y]坐标元素的值表示从0开始走x步到达y的走法
        int[][] arrs = new int[stepCount + 1][10];
        // 初始化第一行,走0步到达0-9些节点的走法数,除了第一个[0][0]，其他的[0][>0]的节点都是没有走法的,所以都为0
        arrs[0][0] = 1;
        // 再往下一行,从0开始走1步到达0-9这些节点的走法
        for (int i = 1; i <= stepCount; i++) {
            for (int j = 0; j < 10; j++) {
                arrs[i][j] = (arrs[i - 1][(j + 1) % 10] + arrs[i - 1][(j - 1 + 10) % 10]) % mod;
            }
        }
        // 目标:从0开始走stepCount步到达0节点的走法数
        return arrs[stepCount][0];
    }
}
```

## LeetCode 70 爬楼梯

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        int[] steps = new int[n];
        steps[0] = 1;
        steps[1] = 2;
        for (int i = 2; i < n; i++) {
            steps[i] = steps[i - 1] + steps[i - 2];
        }
        return steps[n - 1];
    }
```

## LeetCode 23 合并一组升序链表

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

```java
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return Integer.compare(o1.val, o2.val);
            }
        });
        for (int i = 0; i < lists.length; i++) {
            ListNode curr = lists[i];
            while (curr != null) {
                queue.add(curr);
                curr = curr.next;
            }
        }
        // queue汇集全部排序后的节点
        if (queue.size() == 0) {
            return null;
        }
        ListNode header = queue.poll();
        ListNode current = header;
        while (current != null) {
            current.next = queue.poll();
            current = current.next;
        }
        return header;
    }
```

## 无序int数组，给定target，找arr[i]和arr[j]，使得arr[i]*arr[j] = target，返回i，j，如果不存在返回-1，-1；

```java
    public static int[] findOut(int[] arr, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            map.put(arr[i], i);
        }
        for (int i = 0; i < arr.length; i++) {
            // 必须要整除
            if (target % arr[i] == 0) {
                // 整除之后的结果要在数组中存在
                Integer other = map.get(target / arr[i]);
                if (other != null) {
                    return new int[]{i, other};
                }
            }

        }
        return new int[]{-1, -1};
    }
```

## LeetCode 215 返回第k大的元素

> 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
>
> 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

```java
    public int findKthLargest(int[] nums, int k) {
        List<Integer> list = new ArrayList<>();
        for (int item : nums) {
            list.add(item);
        }
        list.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        });
        return list.get(list.size() - k);
    }
```

```java
    public int findKthLargest(int[] nums, int k) {
                quickSort(nums, 0, nums.length - 1);
        return nums[nums.length - k];
    }

    // 手写快速排序
    public static void quickSort(int[] arr, int left, int right) {
        if (left > right) {
            return;
        }
        int i = left;
        int j = right;
        int base = arr[left];
        while (i < j) {
            while (i < j && arr[j] > base) {
                j--;
            }
            while (i < j && arr[i] <= base) {
                i++;
            }
            if (i < j) {
                // 交换
                int swap = arr[i];
                arr[i] = arr[j];
                arr[j] = swap;
            }
        }
        // 交换基准
        base = arr[i];
        arr[i] = arr[left];
        arr[left] = base;
        quickSort(arr, left, i - 1);
        quickSort(arr, i + 1, right);
    }
```

## LeetCode 862 连续字串和至少为k的最短字串

> 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。
>
> 子数组 是数组中 连续 的一部分。

```java
    public int shortestSubarray(int[] nums, int k) {
        int maxLength = nums.length + 1;
        long[] preSum = new long[maxLength];
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < preSum.length; i++) {
            long currSum = preSum[i];
            while (!deque.isEmpty() && currSum - preSum[deque.peekFirst()] >= k) {
                maxLength = Math.min(maxLength, i - deque.pollFirst());
            }
            while (!deque.isEmpty() && preSum[deque.peekLast()] >= currSum) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        return maxLength > nums.length ? -1 : maxLength;
    }
```

```java
    public int shortestSubarray(int[] nums, int k) {
        // 所有和>=k的数组起始位置和长度
        int minLength = -1;
        for (int i = 0; i < nums.length; i++) {
            int currSum = nums[i];
            int currLength = 1;
            for (int j = i + 1; currSum < k && j < nums.length; j++) {
                currSum += nums[j];
                currLength++;
            }
            if (currSum >= k) {
                if (currLength == 1) {
                    return 1;
                }
                if (minLength == -1) {
                    minLength = currLength;
                } else {
                    minLength = Math.min(minLength, currLength);
                }
            }
        }
        return minLength;

    }
```

## 二叉树最近公共祖先

> 最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left == null) {
            return right;
        }
        if (right == null) {
            return left;
        }
        return root;
    }
```

## 判断二叉树是否为对称二叉树

```java
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 比较都左右子树是不是相等的
        return compareLeftRight(root.left,root.right);
    }

    public boolean compareLeftRight(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null && right != null) {
            return false;
        }
        if (left != null && right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return compareLeftRight(left.left, right.right) && compareLeftRight(left.right, right.left);
    }
```

## LeetCode 22 括号生成

```java
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        // 特判
        if (n == 0) {
            return res;
        }

        // 执行深度优先遍历，搜索可能的结果
        dfs("", n, n, res);
        return res;
    }

    /**
     * @param curStr 当前递归得到的结果
     * @param left   左括号还有几个可以使用
     * @param right  右括号还有几个可以使用
     * @param res    结果集
     */
    private void dfs(String curStr, int left, int right, List<String> res) {
        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
        // 在递归终止的时候，直接把它添加到结果集即可
        if (left == 0 && right == 0) {
            res.add(curStr);
            return;
        }

        // 剪枝
        if (left > right) {
            return;
        }

        if (left > 0) {
            dfs(curStr + "(", left - 1, right, res);
        }

        if (right > 0) {
            dfs(curStr + ")", left, right - 1, res);
        }
    }
```

## LeetCode22  三数之和为0

```java
    public List<List<Integer>> threeSum(int[] nums) {
        // 双指针法准备:升序排列
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int k = 0; k < nums.length - 2; k++) {
            // 最小的大于0,直接结束
            if (nums[k] > 0) {
                break;
            }
            // 前后相邻元素值相等,双指针搜索只会得到重复组合
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            int i = k + 1, j = nums.length - 1;
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];

                if (sum < 0) {
                    // 当s < 0时，i += 1并跳过所有重复的nums[i]
                    while (i < j && nums[i] == nums[++i]) {
                    }

                } else if (sum > 0) {
                    // 当s > 0时，j -= 1并跳过所有重复的nums[j]
                    while (i < j && nums[j] == nums[--j]) {
                    }

                } else {
                    //当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]
                    result.add(new ArrayList<>(Arrays.asList(nums[k], nums[i], nums[j])));
                    while (i < j && nums[i] == nums[++i]) {
                    }
                    while (i < j && nums[j] == nums[--j]) {
                    }
                }
            }
        }
        return result;
    }
```

## SQL：查询女性用户最近一天购买量最多的前十个商品

> where 购买时间 >= DATE_SUB(CURDATE(),INTERVAL 1 DAY)  limit 10

## LeetCode11 盛最多水的容器

```java
    public int maxArea(int[] height) {
        // 容量=min(h[i],h[j])×(j−i)
        int i = 0;
        int j = height.length - 1;
        int result = 0;
        while(i < j) {
            // 高度由最短的板决定
            result = height[i] < height[j] ? 
                Math.max(result, (j - i) * height[i++]): 
                Math.max(result, (j - i) * height[j--]); 
        }
        return result;
    }
```

## LeetCode 456:132模式

> 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。
>
> 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。
>
> 
>
> 分析
>
> - 栈的作用：保存到当前遍历位置而言，相对较大的nums[J]。需要明白一点栈中存放的都是有可能成为nums[J]的元素（遍历完成后真正的nums[j]一定是存放在栈中的，只不过是栈顶不一定是nums[J]）。而遍历时 K 存放的则是比真正（当前）nums[J]次小的数字。另外使用栈恰好维护了真正nums[J]和nums[K]的相对顺序。

```java
    public boolean find132pattern(int[] nums) {
        int len = nums.length;
        if (len < 3) {
            return false;
        }
        Stack<Integer> st = new Stack<>();
        int k = -1;
        for (int i = len - 1; i >= 0; i--) {
            if (k > -1 && nums[k] > nums[i]) {
                return true;
            }
            while (!st.isEmpty() && nums[st.peek()] < nums[i]) {
                k = st.pop();
            }
            st.push(i);
        }
        return false;
    }
```



## LeetCode 21 合并两个有序链表

```java
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }

    }
```

## LRU 最近最少使用,自己实现

```java
    public class LRUCache {
        class DoubleLinkedNode {
            int key;
            int value;
            DoubleLinkedNode prev;
            DoubleLinkedNode next;

            public DoubleLinkedNode() {
            }

            public DoubleLinkedNode(int key, int value) {
                this.key = key;
                this.value = value;
            }
        }

        private Map<Integer, DoubleLinkedNode> mapNode = new HashMap<Integer, DoubleLinkedNode>();
        // 双端队列大小
        private int size;
        // 容量
        private int capacity;
        // 头
        private DoubleLinkedNode head;
        // 尾
        private DoubleLinkedNode tail;

        public LRUCache(int capacity) {
            this.size = 0;
            this.capacity = capacity;
            // 伪头部节点
            head = new DoubleLinkedNode();
            // 伪尾部节点
            tail = new DoubleLinkedNode();
            head.next = tail;
            tail.prev = head;
        }

        public int get(int key) {
            DoubleLinkedNode node = mapNode.get(key);
            if (node == null) {
                return -1;
            }
            // 如果 key 存在，先通过mapNode定位，再移到头部
            moveToHead(node);
            return node.value;
        }

        public void put(int key, int value) {
            DoubleLinkedNode node = mapNode.get(key);
            if (node == null) {
                // 如果 key 不存在，创建一个新的节点
                DoubleLinkedNode newNode = new DoubleLinkedNode(key, value);
                // 添加进mapNode
                mapNode.put(key, newNode);
                // 添加至双端队列的头部
                addToHead(newNode);
                ++size;
                if (size > capacity) {
                    // 如果超出容量，删除双端队列的尾部节点
                    DoubleLinkedNode tail = removeTail();
                    // 删除mapNode中对应的项
                    mapNode.remove(tail.key);
                    --size;
                }
            } else {
                // 如果 key 存在，先通过mapNode定位，再修改 value，并移到头部
                node.value = value;
                moveToHead(node);
            }
        }

        private void addToHead(DoubleLinkedNode node) {
            node.prev = head;
            node.next = head.next;
            head.next.prev = node;
            head.next = node;
        }

        private void removeNode(DoubleLinkedNode node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
        }

        private void moveToHead(DoubleLinkedNode node) {
            removeNode(node);
            addToHead(node);
        }

        private DoubleLinkedNode removeTail() {
            DoubleLinkedNode res = tail.prev;
            removeNode(res);
            return res;
        }
    }
```

## 输入一个数字输出汉字

```java

    private static String input;// 输入的数字字符串

    // 单个数字中文表示
    private static String numbers[] = {"零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十"};


    private static String units[] = {"", "十", "百", "千", "万", "十", "百", "千", "亿"};// 单位

    // 将数字字符串串中的每个数字字符按照从左到右的顺序放入数组
    private static String result[];


    /**
     * 输入一串数字，显示汉字读法的方法
     *
     * @param number
     * @return String
     */
    public static String getOutput(int number) {
        String input = number + "";
        StringBuffer sb = new StringBuffer();
        int back = 0;
        result = new String[input.length()];
        for (int i = 0; i < result.length; i++) {
            result[i] = String.valueOf(input.charAt(i));
        }

        for (int i = 0; i < result.length; i++) {
            if (!result[i].equals("0")) {
                back = result.length - i - 1;

                sb.append(numbers[Integer.parseInt(result[i])]);

                sb.append(units[back]);
            } else {
                if (i == result.length - 5 && result[i].equals("0")) {
                    if (result.length == 9 &&
                            result[1].equals("0") &&
                            result[2].equals("0") &&
                            result[3].equals("0")) {
                        sb.append(numbers[0]);
                    } else {
                        sb.append(units[4]);
                    }
                } else {
                    if (i < result.length - 1 && !result[i + 1].equals("0")) {
                        sb.append(numbers[0]);
                    }
                }
            }
        }
        return sb.toString();
    }
```

## LeetCode 394 字符串解码

> 给定一个经过编码的字符串，返回它解码后的字符串。
>
> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
>
> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
>
> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

```java
/*
递归法
总体思路与辅助栈法一致，不同点在于将 [ 和 ] 分别作为递归的开启与终止条件：

当 s[i] == ']' 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；
当 s[i] == '[' 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。
遍历完毕后返回 res
*/
	public String decodeString(String s) {
        return dfs(s, 0)[0];
    }
    private String[] dfs(String s, int i) {
        StringBuilder res = new StringBuilder();
        int multi = 0;
        while(i < s.length()) {
            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') 
                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); 
            else if(s.charAt(i) == '[') {
                String[] tmp = dfs(s, i + 1);
                i = Integer.parseInt(tmp[0]);
                while(multi > 0) {
                    res.append(tmp[1]);
                    multi--;
                }
            }
            else if(s.charAt(i) == ']') 
                return new String[] { String.valueOf(i), res.toString() };
            else 
                res.append(String.valueOf(s.charAt(i)));
            i++;
        }
        return new String[] { res.toString() };
    } 
```

## LeetCode 213 打家劫舍||

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额

```java
    public int rob(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        return Math.max(exeRob(Arrays.copyOfRange(nums, 0, nums.length - 1)),
                exeRob(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    private int exeRob(int[] nums) {
        int pre = 0, cur = 0, tmp;
        for (int num : nums) {
            tmp = cur;
            cur = Math.max(pre + num, cur);
            pre = tmp;
        }
        return cur;
    }
```

## 设计一个秒杀系统

## [二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

> 二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
>
> 叶子节点 是指没有子节点的节点。

```java
     public List<List<Integer>> pathSum(TreeNode root, int target) {
        if (root == null) {
            return new ArrayList<>();
        }
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> nodeList = new ArrayList<>();
        equalTarget(root, target, nodeList, result);
        return result;
    }

    // 假设每个节点的val都是正整数
    // 递归,当前节点是否是满足 = 下一个节点是否满足
    public void equalTarget(TreeNode node, int target, List<Integer> nodeList, List<List<Integer>> result) {
        nodeList.add(node.val);
        // 是否为叶子节点
        if (node.left == null && node.right == null && node.val == target) {
            // 叶子节点
            // 将nodeList保存到列表中
            result.add(new ArrayList<>(nodeList));
            // nodeList删除最后一个
        } else {
            // 非叶子节点
            // 若当前叶子节点的值>=目标值target,(超过了)则直接返回;否则继续下一个节点
            // 若当前叶子节点的值<目标值target,继续下一个节点
            if (node.left != null) {

                equalTarget(node.left, target - node.val, nodeList, result);
            }
            if (node.right != null) {

                equalTarget(node.right, target - node.val, nodeList, result);
            }
        }
        nodeList.remove(nodeList.size() - 1);
    }
```

## 股票的最大利润

> 把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

```java
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        int downPrice = prices[0];
        int maxSubPrice = 0;
        for (int i = 1; i < prices.length; i++) {
            downPrice = Math.min(downPrice, prices[i - 1]);
            maxSubPrice = Math.max(maxSubPrice, prices[i] - downPrice);
        }
        return maxSubPrice;
    }
```

##  输出一个比输入字符串刚好大的字符串，例如1234 -> 1243   -TODO

## 微信抢红包 --TODO

## 二叉树每层的最大值

```java
	// 广度优先搜索
	public List<Integer> largestValues(TreeNode root) {
        if (root == null) {
            return new ArrayList<Integer>();
        }
        List<Integer> result = new ArrayList<Integer>();
        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            int maxVal = Integer.MIN_VALUE;
            while (len > 0) {
                len--;
                TreeNode t = queue.poll();
                maxVal = Math.max(maxVal, t.val);
                if (t.left != null) {
                    queue.offer(t.left);
                }
                if (t.right != null) {
                    queue.offer(t.right);
                }
            }
            result.add(maxVal);
        }
        return result;
    }
```

```java
	// 深度优先
	public List<Integer> largestValues(TreeNode root) {
        if (root == null) {
            return new ArrayList<Integer>();
        }
        List<Integer> res = new ArrayList<Integer>();
        dfs(res, root, 0);
        return res;
    }

    public void dfs(List<Integer> result, TreeNode root, int curHeight) {
        if (curHeight == result.size()) {
            result.add(root.val);
        } else {
            result.set(curHeight, Math.max(result.get(curHeight), root.val));
        }
        if (root.left != null) {
            dfs(result, root.left, curHeight + 1);
        }
        if (root.right != null) {
            dfs(result, root.right, curHeight + 1);
        }
    }

```

## LeetCode 316 去除重复字母

> 一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

```java
public String removeDuplicateLetters(String s) {
        char[] chars = s.toCharArray();
        int[] lastInx = new int[26];
        for (int i = 0; i < chars.length ; i++) {
            lastInx[chars[i] - 'a'] = i; //记录每个元素最后一次出现的位置
        }
        Deque<Character> stack = new ArrayDeque<>();
        boolean[] visited = new boolean[26]; //某一个字符是否在栈中出现
        for (int i = 0; i < chars.length; i++) {
            if (visited[chars[i] - 'a']) { //如果出现舍弃当前字符
                continue;
            }
            //当前字符在栈顶元素之前，且栈顶元素在后面还有
            while (!stack.isEmpty() && stack.peekLast() > chars[i] && lastInx[stack.peekLast() - 'a'] > i) {
                Character c = stack.removeLast();  //移除栈顶元素
                visited[c - 'a'] = false; //表示该字符没有在栈中出现
            }
            stack.addLast(chars[i]);
            visited[chars[i] - 'a'] = true;
        }
        StringBuilder sb = new StringBuilder();
        for(Character c : stack){
            sb.append(c);
        }
        return sb.toString();
    }
```

## LeetCode 1047 [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

> 由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
>
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

```java
    public String removeDuplicates(String s) {
        StringBuffer stack = new StringBuffer();
        int top = -1;
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            if (top >= 0 && stack.charAt(top) == ch) {
                stack.deleteCharAt(top);
                --top;
            } else {
                stack.append(ch);
                ++top;
            }
        }
        return stack.toString();
    }

```

## LeetCode 1029 [删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)

> 一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。
>
> 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
>
> 在执行完所有删除操作后，返回最终得到的字符串。
>
> 本题答案保证唯一。
>

```java
// 记忆计数
/*
从方法一中可以看出，如果为每个字符设置计数器，就不必每次删除完字符后从头开始。这种方法具有线性复杂度，但需要额外空间存储字符的计数器。

算法

初始长度为 n 的数组 counts。

遍历字符串：

如果当前字符与上一个字符相等，令 counts[i] = counts[i - 1] + 1。

否则，令 counts[i] = 1。
如果 counts[i] = k，删除这 k 个字符，令 i = i - k。
*/
public String removeDuplicates(String s, int k) {
    StringBuilder sb = new StringBuilder(s);
    int count[] = new int[sb.length()];
    for (int i = 0; i < sb.length(); ++i) {
        if (i == 0 || sb.charAt(i) != sb.charAt(i - 1)) {
            count[i] = 1;
        } else {
            count[i] = count[i - 1] + 1;
            if (count[i] == k) {
                sb.delete(i - k + 1, i + 1);
                i = i - k;
            }
        }
    }
    return sb.toString();
}

```

## 加油站

> 一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
>
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
>
> > 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> > 输出: 3
> > 解释:
> > 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> > 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> > 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> > 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> > 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> > 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> > 因此，3 可为起始索引。

```java
/*
下图的 黑色折线图 即 总油量剩余值，若要满足题目的要求：跑完全程再回到起点，总油量剩余值 的任意部分都需要在 X 轴以上，且跑到终点时：总剩余汽油量 >= 0。

为了让 黑色折线图 任意部分都在 X 轴以上，我们需要向上移动 黑色折线图，直到所有点都在 X 轴或 X 轴以上。此时，处在 X 轴的点即为出发点。即 黑色折线图 的最低值的位置：index = 3。

作者：cyaycz
链接：https://leetcode.cn/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
public int canCompleteCircuit(int[] gas, int[] cost) {
    int len = gas.length;
    int spare = 0;
    int minSpare = Integer.MAX_VALUE;
    int minIndex = 0;

    for (int i = 0; i < len; i++) {
        spare += gas[i] - cost[i];
        if (spare < minSpare) {
            minSpare = spare;
            minIndex = i;
        }
    }

    return spare < 0 ? -1 : (minIndex + 1) % len;
}
```

## 捡金币游戏：玩家在一条长度为 100 的通道上参加游戏，可以在通道上左右移动，接住天上掉落的价值不同的金币。人初始在 0 点出发，每秒最多可以移动 1 格（也可以在原地保持不动），只有在金币掉落的时刻，玩家走到金币所在位置才能收集到金币。 假设所有金币的掉落时刻 T 和位置 X，价值 V 都是已知的 ，求出最终玩家可以收集到的金币的最大总价值。(d[x][t] = Math.max(d[x][t-1],d[x-1][t-1],d[x+1][t-1]) + V[x];)   --TODO

## LeetCode 222 完全二叉树的节点个数/ 完全二叉树的最后一个节点

```java
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int level = 0;
        TreeNode node = root;
        while (node.left != null) {
            level++;
            node = node.left;
        }
        int low = 1 << level;
        int high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (isExists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    public boolean isExists(TreeNode root, int level, int key) {
        int bits = 1 << (level - 1);
        TreeNode node = root;
        while (node != null && bits > 0) {
            if ((bits & key) == 0) {
                node = node.left;
            } else {
                node = node.right;
            }
            bits >>= 1;
        }
        return node != null;
    }
```

## LeetCode 3 最长不重复字串

```java
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        if (s.length() == 1) {
            return 1;
        }
        int maxLength = 0;
        // 从0开始往后数
        for (int i = 0; i < s.length(); i++) {
            // 当前索引开始的最长不重复字串
            StringBuilder sb = new StringBuilder().append(s.charAt(i));
            for (int j = i + 1; j < s.length(); j++) {
                if (sb.toString().contains(String.valueOf(s.charAt(j)))) {
                    break;
                }
                sb.append(s.charAt(j));
            }
            // sb.length就是以当前索引开始的最长不重复字串
            maxLength = Math.max(maxLength, sb.length());

        }
        return maxLength;
    }
```

## LeetCode 25 k个一组翻转链表

> 链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
>
> k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
        for (int i = 0; i < k && end != null; i++) end = end.next;
        if (end == null) break;
        ListNode start = pre.next;
        ListNode next = end.next;
        end.next = null;
        pre.next = reverse(start);
        start.next = next;
        pre = start;

        end = pre;
    }
    return dummy.next;
}

private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
```

## 小米 编程题

## [连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

> 一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
>
> 要求时间复杂度为O(n)。

```java
    public int maxSubArray(int[] nums) {
        // 核心思想
        // 从前往后遍历,以当前节点为结束的最大字串
        int[] maxArr = new int[nums.length];
        maxArr[0] = nums[0];
        int maxSon = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (maxArr[i - 1] > 0) {
                maxArr[i] = maxArr[i - 1] + nums[i];
            } else {
                maxArr[i] = nums[i];
            }
            maxSon = Math.max(maxSon, maxArr[i]);
        }
        return maxSon;
    }
```

## 最长公共子序列

> 两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
> 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```java
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dparr = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2) {
                    dparr[i][j] = dparr[i - 1][j - 1] + 1;
                } else {
                    dparr[i][j] = Math.max(dparr[i - 1][j], dparr[i][j - 1]);
                }
            }
        }
        return dparr[m][n];
    }
```

## 输出镜像二叉树

```java
// 递归
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode imageNode = new TreeNode(root.val);
        imageNode.right = mirrorTree(root.left);
        imageNode.left = mirrorTree(root.right);
        return imageNode;
    }
// 非递归
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>() {{ add(root); }};
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        }
        return root;
    }
```



## 找出只出现一次的数字

> 一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
>
> 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

```java
    public int[] singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int[] ans = new int[2];
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() == 1) {
                ans[index++] = entry.getKey();
            }
        }
        return ans;
    }
```

## [只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)

> 一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

```java
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
```

